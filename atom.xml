<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一江波,波又波</title>
  <subtitle>jarbob&#39;s personl codesky</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jarbob.com/"/>
  <updated>2016-07-15T04:34:30.000Z</updated>
  <id>http://jarbob.com/</id>
  
  <author>
    <name>江波波</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP mysql PDO 和mysql类的封装</title>
    <link href="http://jarbob.com/2016/07/15/PHP-mysql-PDO-%E5%92%8Cmysql%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://jarbob.com/2016/07/15/PHP-mysql-PDO-和mysql类的封装/</id>
    <published>2016-07-15T03:57:34.000Z</published>
    <updated>2016-07-15T04:34:30.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是pdo?&lt;br&gt;PDO一是PHP数据对象（PHP Data Object）的缩写,是PHP5以后的一种mysql数据驱动对象。&lt;br&gt;现在大多数php框架都包含了对他的支持。&lt;/li&gt;
&lt;li&gt;为什么要自己封装?&lt;br&gt;个人觉得只有自己写的东西,才是最清楚的。当然不否定使用现成的框架,或者再其基础上加以改造   &lt;/li&gt;
&lt;li&gt;&lt;p&gt;这篇博文主要展示在统一接口下轻松实现两种数据驱动类的切换。&lt;/p&gt;
&lt;h2 id=&quot;公共接口-i-DAo-interface-php&quot;&gt;&lt;a href=&quot;#公共接口-i-DAo-interface-php&quot; class=&quot;headerlink&quot; title=&quot;公共接口 i_DAo.interface.php&quot;&gt;&lt;/a&gt;公共接口 i_DAo.interface.php&lt;/h2&gt;&lt;p&gt;限制两个数据对象应该具有相同的方法。代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: jiangbo
 * Date: 2016/1/24
 * Time: 1:05
 * 与mysql接口一致(模型层调用一致)，利用interface
 */
interface i_DAO{
    //获取与前DAO的接口
    public static function getInstance($config = array());
    //执行sql的方法
    public function query($sql = &amp;apos;&amp;apos;);
    //获取全部数据
    public function fetchAll($sql = &amp;apos;&amp;apos;);
    //获取一行数据
    public function fetchRow($sql = &amp;apos;&amp;apos;);
    //获取一个数据
    public function fetchOne($sql = &amp;apos;&amp;apos;);
    //转义sql，防止注入
    public function escapeString($str = &amp;apos;&amp;apos;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;MySqlDB-class-php&quot;&gt;&lt;a href=&quot;#MySqlDB-class-php&quot; class=&quot;headerlink&quot; title=&quot;MySqlDB.class.php&quot;&gt;&lt;/a&gt;MySqlDB.class.php&lt;/h2&gt;&lt;p&gt;这个类是最传统的sqldb 类,依据公共接口,实现其方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: jiangbo
 * Date: 2016/1/19
 * Time: 17:27
 * 单例化的mysql类：3私1公
 */
class MySqlDB implements i_DAO
{
    private $_host;
    private $_port;
    private $_user;
    private $_password;
    private $_charset;
    private $_dbname;
    private $_link;
    /**
     * MySqlDB constructor.
     * @param array $config
     */
    private function __construct($config = array())
    {
        $this-&amp;gt;_initServer($config);//初始化服务器信息
        $this-&amp;gt;_connectServer();//链接服务器
        $this-&amp;gt;_setCharset();//设置字符集编码
        $this-&amp;gt;_selectDB();//选择默认数据库
    }
    private function __clone()
    {
        echo &amp;quot;不能克隆该对象&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
        die();
    }
    private static $_instance;
    public static function getInstance($config = array())
    {
        if (!(static::$_instance instanceof static)) {
            static::$_instance = new static($config);
        }
        return static::$_instance;
    }
    private function _initServer($config)
    {
        $this-&amp;gt;_host = isset($config[&amp;apos;host&amp;apos;]) ? $config[&amp;apos;host&amp;apos;] : &amp;apos;localhost&amp;apos;;
        $this-&amp;gt;_port = isset($config[&amp;apos;port&amp;apos;]) ? $config[&amp;apos;port&amp;apos;] : &amp;apos;3306&amp;apos;;
        $this-&amp;gt;_user = isset($config[&amp;apos;user&amp;apos;]) ? $config[&amp;apos;user&amp;apos;] : &amp;apos;&amp;apos;;
        $this-&amp;gt;_password = $config[&amp;apos;password&amp;apos;];
        $this-&amp;gt;_charset = isset($config[&amp;apos;charset&amp;apos;]) ? $config[&amp;apos;charset&amp;apos;] : &amp;apos;UTF8&amp;apos;;
        $this-&amp;gt;_dbname = isset($config[&amp;apos;dbname&amp;apos;]) ? $config[&amp;apos;dbname&amp;apos;] : &amp;apos;test&amp;apos;;
    }
    private function _connectServer()
    {
        $connect_result = @mysql_connect(&amp;quot;$this-&amp;gt;_host:$this-&amp;gt;_port&amp;quot;, $this-&amp;gt;_user, $this-&amp;gt;_password);
        if ($connect_result) {
            $this-&amp;gt;_link = $connect_result;
        } else {
            echo &amp;apos;数据库连接失败，请确认服务器信息&amp;apos;;
            die();
        }
    }
    private function _setCharset()
    {
        $sql = &amp;quot;SET NAMES $this-&amp;gt;_charset&amp;quot;;
        $this-&amp;gt;query($sql);
    }
    private function _selectDB()
    {
        $sql = &amp;quot;USE `$this-&amp;gt;_dbname`&amp;quot;;
        $this-&amp;gt;query($sql);
    }
    /**
     * 执行SQL语句
     * @param string $sql
     * @return mixed 执行结果。查询类的SQL(select, show, desc),成功返回结果集资源，失败返回false。非查询类(insert, delete, update)，成功返回true，失败返回false.
     */
    public function query($sql)
    {
        $query_result = @mysql_query($sql, $this-&amp;gt;_link);
        if (false == $query_result) {
            echo &amp;quot;SQL执行失败:&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
            echo &amp;quot;错误的SQL:&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;, $sql, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
            echo &amp;quot;错误的消息为:&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;, mysql_errno($this-&amp;gt;_link), &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
            die();
        } else {
            return $query_result;
        }
    }
    /**
     * @param string $sql 通常为:select * from ...
     * @return array
     */
    public function fetchRow($sql)
    {
        $result = $this-&amp;gt;query($sql);
        $row = @mysql_fetch_assoc($result);
        @mysql_free_result($result);
        return $row;
    }
    /**
     * @param string $sql 通常为:select count(*) from ...
     * @return string 如果没有值就返回NULL
     */
    public function fetchOne($sql)
    {
        $result = $this-&amp;gt;query($sql);
        $row = @mysql_fetch_row($result);
        @mysql_free_result($result);
        if ($row)
            return $row[0];
        else
            return NULL;
    }
    /**
     * @param string $sql 通常为:select * from ... where ..like &amp;apos;han%&amp;apos;
     * @return array
     */
    public function fetchAll($sql)
    {
        $result = $this-&amp;gt;query($sql);
        $rows = array();
        while ($row = @mysql_fetch_assoc($result))
            $rows[] = $row;
        @mysql_free_result($result);
        return $rows;
    }
    /*
     * 关闭当前数据库连接, 一般无需使用. 连接会随php脚本结束自动关闭
     */
    /*public function close()
    {
        return @mysql_close($this-&amp;gt;_link);
    }*/
    /**
     * 防止sql注入：转义字符串，在模型中使用
     * @param string $str 带转义的字符串
     * @return string 带引号包裹的转义后的字符串
     */
    public function escapeString($str = &amp;apos;&amp;apos;)
    {
        return &amp;quot;&amp;apos;&amp;quot; . mysql_real_escape_string($str, $this-&amp;gt;_link) . &amp;quot;&amp;apos;&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;PDODB-class-php&quot;&gt;&lt;a href=&quot;#PDODB-class-php&quot; class=&quot;headerlink&quot; title=&quot;PDODB.class.php&quot;&gt;&lt;/a&gt;PDODB.class.php&lt;/h2&gt;&lt;p&gt;为了实现数据对象随意切换,pdo的也需实现应该满足公共接口。代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: jiangbo
 * Date: 2016/1/24
 * Time: 1:00
 * dao层使用dao扩展封装实现
 */
class PDODB implements i_DAO
{
    private $_host;
    private $_port;
    private $_user;
    private $_password;
    private $_charset;
    private $_dbname;
    private $_dsn;
    private $_option;
    private $_pdo;
    /**
     * PDODB constructor.
     * @param array $config
     */
    private function __construct($config = array())
    {
        $this-&amp;gt;_initServer($config);
        $this-&amp;gt;_newPDO();
    }
    private function _initServer($config)
    {
        $this-&amp;gt;_host = isset($config[&amp;apos;host&amp;apos;]) ? $config[&amp;apos;host&amp;apos;] : &amp;apos;localhost&amp;apos;;
        $this-&amp;gt;_port = isset($config[&amp;apos;port&amp;apos;]) ? $config[&amp;apos;port&amp;apos;] : &amp;apos;3306&amp;apos;;
        $this-&amp;gt;_user = isset($config[&amp;apos;user&amp;apos;]) ? $config[&amp;apos;user&amp;apos;] : &amp;apos;&amp;apos;;
        $this-&amp;gt;_password = $config[&amp;apos;password&amp;apos;];
        $this-&amp;gt;_charset = isset($config[&amp;apos;charset&amp;apos;]) ? $config[&amp;apos;charset&amp;apos;] : &amp;apos;UTF8&amp;apos;;
        $this-&amp;gt;_dbname = isset($config[&amp;apos;dbname&amp;apos;]) ? $config[&amp;apos;dbname&amp;apos;] : &amp;apos;test&amp;apos;;
    }
    private function _newPDO()
    {
        //设置参数
        $this-&amp;gt;_setDSN();//设置数据源参数
        $this-&amp;gt;_setOption();//设置选项
        $this-&amp;gt;_getPDO();//得到PDO对象
    }
    private function _setDSN()
    {
        $this-&amp;gt;_dsn = &amp;quot;mysql:host=$this-&amp;gt;_host;port=$this-&amp;gt;_port;dbname=$this-&amp;gt;_dbname&amp;quot;;
    }
    private function _setOption()
    {
        $this-&amp;gt;_option = array(
            PDO::MYSQL_ATTR_INIT_COMMAND =&amp;gt; &amp;quot;set names $this-&amp;gt;_charset&amp;quot;
        );
    }
    private function _getPDO()
    {
        $this-&amp;gt;_pdo = new PDO($this-&amp;gt;_dsn, $this-&amp;gt;_user, $this-&amp;gt;_password, $this-&amp;gt;_option);
    }
    private function __clone()
    {
        echo &amp;quot;不能克隆该对象&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
        die();
    }
    private static $_instance;
    public static function getInstance($config = array())
    {
        if (!(static::$_instance instanceof static)) {
            static::$_instance = new static($config);
        }
        return static::$_instance;
    }
    //执行方法，适用的场景
    private static $_queryStr = array(
        &amp;quot;select&amp;quot;,
        &amp;quot;show&amp;quot;,
        &amp;quot;desc&amp;quot;
    );
    public function query($sql = &amp;apos;&amp;apos;)
    {
        //使用正则过滤，分别使用query和exec
        foreach (static::$_queryStr as $str){
            if (preg_match(&amp;quot;/^\s*&amp;quot;.$str.&amp;quot;.*?/i&amp;quot;,$sql)){
                //查询类 返回结果集对象
                $result = $this-&amp;gt;_pdo-&amp;gt;query($sql);
            }else{
                //非查询类 返回bool
                $result = $this-&amp;gt;_pdo-&amp;gt;exec($sql) !== false;//有可能是0
            }
            //如果执行失败，报错
            if($result === false){
                $error_info = $this-&amp;gt;errorInfo();
                echo &amp;quot;SQL执行失败:&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
                echo &amp;quot;错误的SQL:&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;, $sql, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
                echo &amp;quot;错误的消息为:&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;, $error_info[2], &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
                die();
            }else{
                return $result;
            }
            break;
        }
    }
    public function fetchAll($sql = &amp;apos;&amp;apos;)
    {
        $result = $this-&amp;gt;query($sql);
        $rows = $result-&amp;gt;fetchAll(PDO::FETCH_ASSOC);
        $result-&amp;gt;closeCursor();
        return $rows;
    }
    public function fetchRow($sql = &amp;apos;&amp;apos;)
    {
        $result = $this-&amp;gt;query($sql);
        $row = $result-&amp;gt;fetch(PDO::FETCH_ASSOC);
        $result-&amp;gt;closeCursor();
        return $row;
    }
    public function fetchOne($sql = &amp;apos;&amp;apos;)
    {
        $result = $this-&amp;gt;query($sql);
        $string = $result-&amp;gt;fetchColumn();
        $result-&amp;gt;closeCursor();
        return $string;
    }
    public function escapeString($str = &amp;apos;&amp;apos;)
    {
        return $this-&amp;gt;_pdo-&amp;gt;quote($str);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;模型层实例化数据对象-并达到随意切换&quot;&gt;&lt;a href=&quot;#模型层实例化数据对象-并达到随意切换&quot; class=&quot;headerlink&quot; title=&quot;模型层实例化数据对象,并达到随意切换&quot;&gt;&lt;/a&gt;模型层实例化数据对象,并达到随意切换&lt;/h2&gt;&lt;p&gt;实例化代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: jiangbo
 * Date: 2016/1/19
 * Time: 1:02
 * 基础模型类
 */
class Model{
    /**
     * DAO : captcha access object
     */
    protected $_dao;//存储实例化好的数据库对象
    /**
     * Model constructor.
     */
    public function __construct()
    {
        $this-&amp;gt;_initDAO();//初始化基础模型
    }
    protected function _initDAO(){
        //require_once &amp;quot;./framework/MySqlDB.class.php&amp;quot;;
        $config = array(
            &amp;apos;host&amp;apos; =&amp;gt; &amp;apos;localhost&amp;apos;,
            &amp;apos;user&amp;apos; =&amp;gt; &amp;apos;root&amp;apos;,
            &amp;apos;password&amp;apos; =&amp;gt; &amp;apos;&amp;apos;,
            &amp;apos;dbname&amp;apos; =&amp;gt; &amp;apos;project&amp;apos;
        );
        //$this-&amp;gt;_dao = MySqlDB::getInstance($config);//调用mysqldb
        $this-&amp;gt;_dao = PDODB::getInstance($config);//调用pdo
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然,代码还可以用一个公共配置文件来指定数据对象的类型和配置数据。&lt;/p&gt;
&lt;p&gt;好了,教程到此结束。如果您对此过程感到满意,你还可以继续看看我在&lt;a href=&quot;https://github.com/jarbob/MyPhpFramework/tree/JBPhpFramework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gayhub&lt;/a&gt;开源的一个php框架,代码有详细的注释,并且入口文件没有做任何模块化配置文件,一边加深对php框架的学习印象。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是pdo?&lt;br&gt;PDO一是PHP数据对象（PHP Data Object）的缩写,是PHP5以后的一种mysql数据驱动对
    
    </summary>
    
      <category term="php" scheme="http://jarbob.com/categories/php/"/>
    
    
      <category term="mysql" scheme="http://jarbob.com/tags/mysql/"/>
    
      <category term="pdo" scheme="http://jarbob.com/tags/pdo/"/>
    
  </entry>
  
  <entry>
    <title>利用js模拟ping实现智能选择线路跳转网站</title>
    <link href="http://jarbob.com/2016/07/10/%E5%88%A9%E7%94%A8js%E6%A8%A1%E6%8B%9Fping%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E9%80%89%E6%8B%A9%E7%BA%BF%E8%B7%AF%E8%B7%B3%E8%BD%AC%E7%BD%91%E7%AB%99/"/>
    <id>http://jarbob.com/2016/07/10/利用js模拟ping实现智能选择线路跳转网站/</id>
    <published>2016-07-10T14:02:26.000Z</published>
    <updated>2016-07-14T13:48:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　由于项目中用到js类似shell下的ping，而且前提是目标站服务器没有权限，我们不能配置其服务器允许跨域，所以这使得不能跨域的ajax失效，另外还要考虑到兼容性，一些h5下的技术如websocket也没法使用。&lt;/p&gt;
&lt;h2 id=&quot;尝试&quot;&gt;&lt;a href=&quot;#尝试&quot; class=&quot;headerlink&quot; title=&quot;尝试&quot;&gt;&lt;/a&gt;尝试&lt;/h2&gt;&lt;p&gt;　　既然要解决跨域，那么首先考虑到的图片ping。代码大概如下：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;br&gt;var img = new Image();&lt;br&gt;var start = new Date();&lt;br&gt;var t = 0;&lt;br&gt;img.onload = img.onerror = pingCheck;&lt;br&gt;function pingCheck() {&lt;br&gt;    t = new Date() - start;&lt;br&gt; }&lt;br&gt;img.src = url + “/?” + (+new Date());&lt;br&gt;&lt;/pre&gt;&lt;br&gt;以上代码只是简单实现了图片ping的核心，另外还要写函数用来判断哪个url的时间短，并进行location。  但是上线正式测试之后，发现这个真是一团糟，如果目标站服务器挂了，或者client的网速不好时，整个页面将无限循环，于是你的js越写越复杂，定时器越写越多，用来排除各种错误。&lt;/p&gt;
&lt;p&gt;##探索&lt;br&gt;某天就在本屌正在怀疑人生的时候，突然发现有人提到&lt;font color=&quot;red&quot;&gt;如何防止网站被别人iframe调用&lt;/font&gt;，并提到在自己的网站加入以下js即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (self != top){
    top.location.href = self.location.href;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本屌顿时有点想法，因为目标站正好加了这个代码。  于是乎本人的新版iframe版代码就这样出现了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Ping = function () {
 };

Ping.prototype.urlArr = new Array();
Ping.prototype.check = function (u) {

$(&amp;quot;&amp;lt;iframe style=&amp;apos;display: none&amp;apos; width=&amp;apos;1&amp;apos; height=&amp;apos;1&amp;apos; id=&amp;apos;PingFrame&amp;apos;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;quot;).appendTo(&amp;apos;body&amp;apos;);
$(&amp;quot;#PingFrame&amp;quot;).attr(&amp;quot;src&amp;quot;, u);

};

Ping.prototype.ping = function () {
var arr = this.urlArr;
for(var i =0; i &amp;lt; arr.length; i++){
    //console.log(arr[i]);
    this.check(&amp;quot;http://&amp;quot; + arr[i]);
}
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好吧，这样就简简单单的实现咯~~~&lt;br&gt;好吧，详情请看&lt;a href=&quot;https://github.com/jarbob/JqueryPing.iframe.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　由于项目中用到js类似shell下的ping，而且前提是目标站服务器没有权限，我们不能配置其服务器允许跨域，所以这使得不能跨域的ajax
    
    </summary>
    
      <category term="web" scheme="http://jarbob.com/categories/web/"/>
    
    
      <category term="js" scheme="http://jarbob.com/tags/js/"/>
    
      <category term="ping" scheme="http://jarbob.com/tags/ping/"/>
    
  </entry>
  
</feed>
